---
id: 1573
title: 'Building Microservices &#8211; Patterns, Principles &#038; Practices of DDD &#8211; Clean Code &#038; Software Craftsman | Lecturas recomendadas'
date: '2017-03-31T20:27:42+00:00'
author: Jose
layout: revision
guid: 'http://josecuellar.net/1489-revision-v1/'
permalink: '/?p=1573'
---

No podemos permitirnos el lujo de caer en la monotonía técnica y dejarnos llevar por las mismas formas de hacer las cosas una y otra vez y de la manera que ya conocemos. Necesitamos hacer un esfuerzo en **seguir aprendiendo y mantenernos actualizados** siempre que nos sea posible. Si tu horario laboral no te lo permite o no es suficiente, hazlo en casa: Si te apasiona la programación y todo lo que le rodea, como en mi caso, no te supondrá ningún esfuerzo sino todo lo contrario. El aprendizaje continuo día a día, educación permanetente o [lifelong learning](https://en.wikipedia.org/wiki/Lifelong_learning). Entre tantos y tantos libros interesantes, lo importante es elegir bien cuales leer y cuales de ellos se convertirán en nuestros consejeros. Me gustaría compartir algunos comentarios de los libros que he leído los últimos meses y que os recomiendo leer.

---

<div style="margin-bottom:20px;clear:both;"></div> ![](/wp-content/uploads/building-microservices.jpg)2015 - Autor: [Sam Newman](http://www.oreilly.com/pub/au/6132). Con el tiempo y si no se presta la atención suficiente es fácil generar una [arquitectura monolítica](https://en.wikipedia.org/wiki/Monolithic_application) o lo que es peor, una arquitectura monolítica convertida en un gran sistema acoplado o [Big ball of mud](https://en.wikipedia.org/wiki/Big_ball_of_mud). Pueden seguirse los principios: [Single Responsability Principle, Separation of Concerns, Low Coupling &amp; High cohesion](/principios-a-seguir-en-el-diseno-de-un-sistema/) utilizando una arquitectura monolítica aunque siempre estarás *atado* a un único sistema conjunto con todas las funcionalidades. En la medida de lo posible debemos dar un paso más allá y dividir el sistema según sus responsabilidades. El enfoque *Domain Driven Design* y sus patrones estratégicos ya introdujeron la división del dominio en los llamados [Bounded Context](/domain-driven-design-episodio-i-empezando/) y como colaboran entre ellos mediante los [Context Mappings](/domain-driven-design-episodio-ii-context-maps/). La propuesta de una arquitectura de *microservicios* se basa en la división mayor de responsabilidades y desarrollar un conjunto de pequeños microservicios que darán soporte a un sistema distribuido. El libro nos aconseja las mejores estrategias para *disgregar* la base de datos de nuestro *sistema monolítico* en varias base de datos que den soporte a los diversos *microservicios* según la responsabilidad de cada uno y como gestionar las relaciones si las hubiera entre ellas. Así como estrategias y herramientas de automatización de *deploy/desplegado* para desplegarlos de forma aislada, autónoma y transparente para el conjunto del sistema, como por ejemplo [Docker](https://www.docker.com/). Dicha *granularidad* en los *microservicios* nos permite escoger el lenguaje de programación idóneo dependiendo de su responsabilidad, escalar y rastrear errores más eficazmente. [API REST](https://es.wikipedia.org/wiki/Transferencia_de_Estado_Representacional) como principal protocolo de acceso, colaboración y consumo. Herramientas de *traceo* que permiten el *monitoreo* de toda la actividad entre *microservicios*, como por ejemplo [ELK (ElasticSearch, Logstash y Kibana)](https://www.elastic.co/webinars/introduction-elk-stack). Me llamó la atención un comentario en el que priorizan incumplir *DRY* (duplicando código en *microservicios*) con tal de favorecer [Single Responsability Principle, Separation of Concerns, Low Coupling &amp; High cohesion](/principios-a-seguir-en-el-diseno-de-un-sistema/). Dado que pueden ser peores los inconvenientes generados en el acoplamiento que sucede en la reutilización de código. Nos recomienda algunas estrategias en la capa de *UI* para generarlas mediante las peticiones a varios microservicios que retornen contenidos de HTML o la información necesaria para realizar el *renderizado* en el cliente. También llamadas [Composed UI](http://microservices.io/patterns/ui/client-side-ui-composition.html) *Puedes comprarlo [aquí](https://www.amazon.es/Building-Microservices-Designing-Fine-Grained-Systems-ebook/dp/B00T3N7XB4/ref=tmm_kin_swatch_0?_encoding=UTF8&qid=&sr=).* <u>Puedes además ampliar la información aquí:</u> [Introduction to Microservices](https://www.nginx.com/blog/introduction-to-microservices/?utm_source=refactoring-a-monolith-into-microservices&utm_medium=blog&utm_campaign=Microservices) [Microservices and Front-End](https://technologyconversations.com/2015/08/09/including-front-end-web-components-into-microservices/) [The Monolithic Frontend In The Microservices Architecture](http://blog.xebia.com/the-monolithic-frontend-in-the-microservices-architecture/)---

<div style="margin-bottom:20px;clear:both;"></div> ![](/wp-content/uploads/pattern-practices-ddd.jpg)2015 - Autor: [Scott Millett](http://www.elbandit.co.uk/blog/). El libro perfecto para profundizar los patrones, principios y prácticas de desarrollo mediante un enfoque de *DDD* plasmado en ejemplos prácticos. Fue el segundo libro que leí después de [Implementing DDD](/domain-driven-design-episodio-i-empezando/) y fue una buena elección ya que solucioné muchas de las dudas de interpretación que tenía pendientes. En la primera parte del libro se centra en explicar los patrones estratégicos de DDD, aunque con ciertos matices a la división del dominio y otros conceptos, para en capítulos posteriores profundizar en temas más tácticos como [CQRS](/domain-driven-design-episodio-iii-arquitectura/), patrones que nos ayudarán al desarrollo como [Command (processor) pattern](https://en.wikipedia.org/wiki/Command_pattern), [Double Dispatch pattern](https://en.wikipedia.org/wiki/Double_dispatch), [Memento pattern](https://es.wikipedia.org/wiki/Memento_(patr%C3%B3n_de_dise%C3%B1o)), implantación de [Event Sourcing](/domain-driven-design-episodio-iii-arquitectura/), [Event Store](http://blog.arkency.com/2015/03/explaining-gregs-event-store/), reconstrucción de los agregados y adaptación con otros patrones de diseño como el [Repository pattern](http://deviq.com/repository-pattern/), [Unit of Work pattern](https://lostechies.com/derekgreer/2015/11/01/survey-of-entity-framework-unit-of-work-patterns/), [Table Module pattern](https://martinfowler.com/eaaCatalog/tableModule.html), [Data Driven programming](https://en.wikipedia.org/wiki/Data-driven_programming), [Model Driven](https://en.wikipedia.org/wiki/Model-driven_engineering), [Active Record pattern](https://es.wikipedia.org/wiki/Active_record), [Transaction Script pattern](https://martinfowler.com/eaaCatalog/transactionScript.html) o [Mediator/Visitor pattern](https://en.wikipedia.org/wiki/Mediator_pattern). Todos ellos explicados con gráficos y ejemplos. Además también nombra algunos antipatterns que deberíamos evitar como [God Object](https://es.wikipedia.org/wiki/Objeto_todopoderoso) o [Anemic Domain model](https://en.wikipedia.org/wiki/Anemic_domain_model). Es un libro muy recomendable por la gran cantidad de ejemplos de código donde refleja mucha de la teoría de los patrones tácticos del enfoque *DDD*, así como algunos de los patrones de diseño más utilizados. El libro me solventó muchas dudas con respecto al *CQRS/ES* y reconstrucción de agregados mediante el [Event Stream](https://en.wikipedia.org/wiki/Event_stream_processing) y la gestión de proyecciones o *snapshots* que ayudan a la reconstrucción del agregado de una forma más eficiente. [RPC](https://es.wikipedia.org/wiki/RPC), [SOA](https://es.wikipedia.org/wiki/Arquitectura_orientada_a_servicios), [EDA](https://es.wikipedia.org/wiki/Arquitectura_dirigida_por_eventos), [consistencia eventual](https://en.wikipedia.org/wiki/Eventual_consistency) y otros menesteres interesantes con ejemplos claros, concisos y completos utilizando las herramientas/prácticas más utilizadas en cada caso. Además dedica ciertos capítulos en explicar las principales herramientas y técnicas más útiles que nos facilitarán seguir los patrones y prácticas recomendadas como: [Fluent API](https://en.wikipedia.org/wiki/Fluent_interface), [MassTransit](http://masstransit-project.com/), [NServiceBus](https://particular.net/nservicebus), [RabbitMQ](https://www.rabbitmq.com/). Me gustan la diversidad de gráficos que el libro emplea. La gran mayoría de veces una imagen vale más que mil palabras. Estoy muy seguro, que a pesar de subrayar lo que creo más importante, será un libro que consultaré en muchas ocasiones. *Puedes comprarlo [aquí](https://www.amazon.es/Patterns-Principles-Practices-Domain-Driven-Design/dp/1118714709).*---

<div style="margin-bottom:20px;clear:both;"></div> ![](/wp-content/uploads/cleancode.png)2008 - Autor: [Robert Cecil Martin](https://en.wikipedia.org/wiki/Robert_Cecil_Martin). La biblia de todo buen programador. Nos enseña buenas prácticas que nos ayudarán a mejorar la legibilidad y mantenibilidad del código que generamos a lo largo del tiempo. Pautas y guías recomendadas para crear código de calidad bien estructurado. Con ejemplos de código en cada caso. En una primera parte del libro explica que es un código limpio y qué beneficios obtendremos para después hacernos entender los mejores prácticas mediante ejemplos de *refactorización* de código. Codificar con intención de que cualquier persona pueda entender el código, sepa o no sepa programar. La importancia del orden de declaración de los elementos, así como los nombres descriptivos de las variables, propiedades, métodos, clases, módulos, etc. Los grandes beneficios de la cobertura de test y la recomendación de realizar siempre que sea posible TDD siguiendo los principios de la correcta generación de los test unitarios mediante [F.I.R.S.T](https://github.com/ghsukumar/SFDC_Best_Practices/wiki/F.I.R.S.T-Principles-of-Unit-Testing). Por último nos facilita información para poder detectar fragmentos de código que necesitan ser refactorizados o [code smell](https://en.wikipedia.org/wiki/Code_smell). Seguro que te pasará lo mismo que a mí: en cuando lo hayas leído te arrepentirás de no haberlo hecho antes :) *Puedes comprarlo [aquí](https://www.amazon.es/dp/0132350882/ref=pd_lpo_sbs_dp_ss_1?pf_rd_p=556244407&pf_rd_s=lpo-top-stripe&pf_rd_t=201&pf_rd_i=0134052501&pf_rd_m=A1AT7YVPFBWXBL&pf_rd_r=YD5S5F3VGYF6F8H67EBR).*---

<div style="margin-bottom:20px;clear:both;"></div> ![](/wp-content/uploads/sandromancuso.png)2014 - Autor: [Sandro Mancuso](https://codurance.com/blog/author/sandro-mancuso/). Entender y dar la importancia necesaria en la calidad técnica del producto que entregamos. Dando importancia al conocimiento y a la práctica constante para ser mejores profesionales día a día. Prestando atención a todo el proceso en la entrega de valor de producto implicándose en las soluciones de principio a fin. El autor [Sandro Mancuso](https://codurance.com/blog/author/sandro-mancuso/) cuenta sus inicios y como evoluciona en las diversas etapas en su carrera profesional. Destacando la importancia en dar los pasos correctos orientando y decidiendo en todo momento lo mejor para nuestro futuro profesional sin dejar al azar o que otros puedan decidir por nosotros. Mantener nuestros conocimientos y habilidades actualizados mediante el aprendizaje y entrenamiento continuo compartiéndolo con la comunidad. Existen grupos de [meetups](https://www.meetup.com/es-ES/) en diversas ciudades donde realizan [Katas](https://en.wikipedia.org/wiki/Kata_(programming)) o prácticas de desarrollo donde entrenar nuestras habilidades: [Sosftware Craftsmanship Barcelona](https://www.meetup.com/es-ES/Barcelona-Software-Craftsmanship/) El libro dedica varios capítulos a dar consejos y explicar buenas prácticas para *captar talento y pasión a la organización*. Ya que los procesos tradicionales de selección de personal no es lo suficientemente refinado como para atraer el verdadero talento a la compañía. Utilizando comparaciones de ofertas de empleo tradicionales con un nuevo modelo recomendable donde se intenta plasmar la pasión por la tecnología dando un papel importante a la calidad en el desarrollo de sus productos. Reflejando una cultura de empresa que apuesta por el conocimiento interno continuo y con la colaboración activa colectiva para la mejora continua de sus productos. Los grandes beneficios del uso de técnicas de [eXtreme Programming](https://es.wikipedia.org/wiki/Programaci%C3%B3n_extrema): [TDD](https://es.wikipedia.org/wiki/Desarrollo_guiado_por_pruebas), [BDD](https://es.wikipedia.org/wiki/Desarrollo_guiado_por_comportamiento), [Code review](https://es.wikipedia.org/wiki/Revisi%C3%B3n_de_c%C3%B3digo), [Pair programming](https://es.wikipedia.org/wiki/Programaci%C3%B3n_en_pareja), [Mob programming](https://en.wikipedia.org/wiki/Mob_programming) y otras técnicas que apuestan por la *robustez* técnica que mejorando resultado final del producto, la satisfacción del cliente y su buena evolución a lo largo del tiempo. A pesar de centrarse en la importancia de la calidad, el libro nos aconseja ser *pragmáticos* y no caer en la teoría excesiva de todos los temas que pueden llegar a ser un obstáculo en la toma de decisiones y en el desarrollo *ágil* de las soluciones enfocadas a la entrega de valor del producto. *Puedes comprarlo [aquí](https://www.amazon.es/Software-Craftsman-Professionalism-Pragmatism-Robert/dp/0134052501).*