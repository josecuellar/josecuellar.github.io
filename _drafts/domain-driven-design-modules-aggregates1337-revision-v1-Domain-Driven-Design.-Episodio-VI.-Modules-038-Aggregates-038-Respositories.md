---
id: 1341
title: 'Domain-Driven Design. Episodio VI. Modules &#038; Aggregates &#038; Respositories'
date: '2016-10-19T15:45:50+00:00'
author: Jose
layout: revision
guid: 'http://josecuellar.net/1337-revision-v1/'
permalink: '/?p=1341'
---

Modules Los módulos son contenedores de elementos que nos permiten cierta organización entre los componentes definidos de nuestro dominio. Denominados técnicamente como packages o namespaces. El objetivo principal es desacoplar los elementos entre los elementos que se encuentran en diversos módulos. Siguiendo en todo momento el lenguaje obícuo establecido es importante nombrar correctamente los módulos. Basic Module Naming Conventions Cuando exista y se use un nombre de dominio en internet, típicamente empezará el nombre del módulo con com, seguido del nombre de la organización. com.sasovation Module naming conventions for the model and submodules El siguiente segmento del nombre de módulo identifica el Bounded Context donde se aloja el módulo o contenedor de elementos. Es una mala decisión utilizar los nombres comerciales de los productos en los nombres de módulos, ya que éstos pueden cambiar y en ocasiones el nombre no guarda relación directa con el Bounded Context al que pertenece. Es preferible [identificar el nombre del Bounded Context](http://josecuellar.net/domain-driven-design-episodio-i-empezando/) según la organización que el equipo decida. El objetivo es reflejar el lenguaje obícuo. Además los módulos deben identificar en qué componente del sistema se encuentra. En sistemas con arquitecturas por capas, sería recomendable utilizar los nombres específicos según dicha capa. Internamente en cada módulo de capa, debe desglosarse o dividirse según componentes internos en submódulos. Aggregates Clustering entities and value objects into an aggregate with a carefully crafted consistency boundary may at first seem like quick work, but among all ddd tactical guidance, this pattern is one of theleast well undertood. Un gran agregado es atractivo pero no es lo más pra´ctico. Our aggregate instances emply optimistic concurrency to protect persistent objects from simultaneous overlapping modifications by different clients thus avoiding the use of database locks. As discussed in entities objects carry a version number that is incremented when changes are made and checked before they are saved to the databaswe. If the version on the persisted object is greater than the version on the client´s copy, the client´s is considered stale and updates are rejected. If you argue that the default concurrency configurations can be changed, reserve our verdict for a while longer. This approach is actually important to protecting aggregate invariants from concurrent changes. Multiple aggregate: Now consider an alternative model. Breaking the singloe large aggregate into four will change some method contracts on product. With the large-cluster aggregate design the method signatures looked like this true invariaants in consistency boundaries When trying to discover the aggregates in bounded context, we must undertand the model´s true invariants. Only with that knowledge can we determine which objects should be clustered into a given aggregate. An invariant is a business rule ghat must always be consistent. One is transactional conssistency, which is considered immediate and atomic. There is algo eventual consistency. When discussing invariants, we are referring to transactional consistency. Whe might have the invariant. Therefore, when a is 2 and b is 3 , c must be 5. According to that rule and conditions, if c is anything but 5, a sistem invariant is violate. To ensure that c is consistent, we design a boundary around these especific atributes of the model. Thus, aggregates is synonymous with transactional consistency boundary. When employing a typical persistence mechanism, we use a single trnsaction to manage consistency. When the trasaction commints, everything inside one boundary must be consistent. A propertly designed aggregate is one that can be modified in any way required by the business with its invariants completely consistent within a single trasaction. And a properly designed bounded context modifies only one aggregate instance per transaction in all cases. Limiting modification to one aggregates instance per transaction may sound overly strict. However, it is a rule of thumb and should be the goal in most cases. It adresses the very reason to use aggregates. The fact that aggregates must be designed with a consistency focus implies that the user interface should concentrate each request to execute a single command on just one aggregate instance. Even so, typically invariants will be less demanding on out modeling efforts, making it possible to design SMALL AGREGATE. rule: design small aggregates: even if we guarantee that every trnsaction would succed, a large cluster still limpits performance and scalability. We almost never load all backlogs items, releases, and scripts an onece. Still, thousands of backlog items would be loaded into memory justo to add one new element to the already large collection. It is worse if a persistencie mechanism does not support lazy loading. This large-cluster aggregate will never perform or scale well. It is more likely to become a nightmare leading only to faileure. if we are going to design small agregates, what does small mean=? the extreme woujld be an aggregate with only its blogally unique identify and one additional attribute, wich is not what´s being recomended. Rather limit the aggregate to just the root entity and a minimal number of attributes or value typed properties. The correct minimum is however many are necesary and no more. Those that must be consistent with others, even if domain experts don´t specify them as rules. Cases where instances can be completely replaced point to the use of a value object rather than and entity. At times entity parts are necessary. Yet, if we run throung this design exercicse on a case by case basis, many concepts modeled as entities can be rectored to value object. Favoring value types asaggregate parts doesn´t mean the agregates isimmutable since de root entity itself mutables when one of its value-typed properties is replaced. Smaller aggregates not only perform and scale beetter, the are also biased towared transactional success, meaning that conflicts preventigng a commit are rare. This makes a system more usable. Your domain no often have true invariant constraints that force you into large-composition design situations. Therefore, it is just plain smart to limit aggregate size. When you occasionally encounter a true consistency rule, add another few entities, or posibly a collection, as necessary, but continue to push yourself to keep the overall size a small as posible. Rule: reference other aggregates by identity When designing aggregates, we may desire a compositional structure that allows forstates that one oaggregate may hold references to the root of other aggregates. However, we must keep in mind that this does not place the referenced aggregate inside the consistency boundary of the one refrerencing it. The reference does not cause the formation of just one whole aggregate. There are still two or more. Referenciando por id en vez de asociaciones nos permitirá separar los agregados y poder crear así las modificaciones pertinentes en el agregado en una única transacción, pudiendo generar transacciones eventuales de forma independiente siendo así escalable las modificaciones evitando los bloqueos en la fuente de datos De modo que pueden modificarse en transacciones diferentes por cada instancia de agregado. Aggregates with inferred object references are thus automatically smaller becuause reference are never eagerly loaded. The model can perform better because instances require less time to load and take less memory. Using less memory has positive implications for both memory allocations overhead and garbage collection. Model navigation. This technique is called disconnected domain model, and it´s actually a form of lazy loading. There´s a diferrent recommended approach, however use a repository or domain service to look up dependent object ahead of involkingthe aggregate behavior. A client application service may control this, then dispatch to the aggregate. Having an application service resolve dependencies frees the aggregate from relying on either a repository or a domain service. However, for very complex and domain-specific dependency resolutions, passing a domain service into a an aggregate command method can be the best way to go. The aggregate can then double- dispatch to the domain service to resolve referencies. Again, in whatever way on e aggregate gains acces to others, reference multiple aggregates in one request does no t give license to cause modification on two or more of them. You may have to use multiple repositories in a single use case to populate views. IUf query overhead causes performance issues, it may be worth considering the us of theta joing or CQRS. Making aggregates smaller leads to better-performing models, plus we can add scalability and distribution. Scalability and distribution Since aggregates don´t use direct reference to other aggregates but reference by identity, their persistent state can be moved around to reach large scale. Almost infinite scalability is achieved by allowing for continous repartitioning of aggregate data storage, as explained by amazon.com. But what he describes is still an aggregate by any other name: a unit of composition that has transactional consistency. Some nowsql persistence. Since there are always multiple bounded contexts at play in a given core domain inititive, reference by identity allows distributed domain models to have associations from afar. When an event-driven approach is in use, message based domain events containing aggregate identities are send atound the enterprise. Message subscribers in foreign bounded contexts use the identity to carry out operations in their own domain models. Transactions across distributed systems are not atomic. Necesitamos despiezar las entidades o agregados para poder manipularlos de form distribuida sin perder la relacion mediante los identificaciones. Use eventual consistency outside the boundary: Any rule that spans aggregates will not be expected to be up to date at all times,. Throught event processing, batch processing, or other update mechanisms, other dependencies can be resolved within some specific time. Thus, if executing a command on one aggregate instance requires that additional business rules execute on or more other aggregate use eventual consistency. Ask the domain experts if they could tolerate some time delay between the modification of one instance and the others envolved. atomic change mentality not is good in disgributed systems. There is a practical way to support eventual consistency in a ddd model. An aggregate command method published a domain event that is in time delivered to one or more asyncrhronous subscribers. Each of these subscribers then retrieves a different yet corresponding aggregate instance and executes its behaviour based on it. Reasons to break the rules an experienced ddd practitiones may at time decide to persist changes to multiple aggregate instances in a signle transaction, but only with good reason. What might some reasons be? razon 1: user interface convenience. razon 2: lack of technical mechanisms in such cases project synamics may force us to modify two or more aggregate instance in one transaction. However obvious this might seem, such a decision should not be made too hastily. Razon 3: global transactions. razon 4 : query performance Rethinking the design, again create a root entity with unique identity using law of demeter and tell, don´t ask both law of demeter and tell, don´t ask are design principles that can be used when implementing aggregates, both of wich stress infromation hiding. Consider the high -level guiding principles to see how we can benefit: shourld know as little as possible about the server´s structure. The server´s attributes and properties- its shape- should remain completely unknown to the client. if the client needs a service that is rendered by the server´s inner parts, the client mus not be given access to the inner parts to request that behavior. Tell don´t ask: this guideline simply asserts that objects should be told what to do. The don´t ask part ot the guideline applies to the client as follows: a client object should not ask a server object for its contained parts, You will need to weigh the competing forcesbetween use of law of demeter and tell, don´t ask. Certainly the law of demeter approach is much more restrictive, disallowing all navigation into aggregate parts beyond the root. On the other hand, the use of tell, don´t ask allows for navigation beyond the root but does stipulate that modification of the aggregate state belongs to the aggregate , not the licent. You may thus find tell, don´t ask to be a more brodaly aplplicable approach to aggregate implementation. Opptimistic concurrency Next, we need to consider whre to place the optimistic concurrency version attribute. When we contemplate the definition of aggregate, it could seem safest to version only the root entity. The root´s version would be incremented every time a state-altering command is executed anywhereinside the aggregate boundary, no matter how deep. Using the running example, woul.... versión del objeto para determinar la modificcacione en los execute commands, para evitar bloquear el registro. Antes de persistir la entidad nos aseguramos de la verisón del objeto que hay ya persistido para evitar realizarla. FACTORIES Of all the patterns used in ddd, factory is probably one of the better known. Highly publicized in design patterns are abstract factory, factory method and builder. I won´t in any way attempt to overhadow the advice given there, or that provided by evans. The focus here is to provide examples of how you can use factories in the domain model. Shift the responsability for creating instances of complex objects and aggregates to a separate object, which may itself have no reponsability in the domain model but is still part of the domain design. Factory method for producing instance of another agregate type will have the primary responsability of providing it main agregate behavior, the factory medhod being just one of those. En vez de disponer de un constructor con un montón de parámetros dispondremos de un factory method que nos ayudará a generar la instancia del agregado dependiendo del lenguaje obicuo. The sample bounded context do in some cases require complex construction. evita que se generen instancias incorrectas controlando la complejidad de la instancia en ellas. factory on service. since much of whow i use services as factories is rrelated to nos ayuda a aprender como creamos instancias de agregados de otros tipos asegurándonos una correcta producción y iformación sensible. hemos aprendido omo los servicios de dominio pueden iddiseñarswe como factorieas incluyendo en otro dounded context y traduciendo bojetos locales. REPOSITORIES respository commonly referes to a storage location, usually considered a place of safety or preservation of the items stored in it. When you store something in a arepository and later return to retrive, you expect that it will be in the same state as ikt was in when you put it there. At some poing you may choose to remove the stored item from the repository. This basic set of principles applies to a ddd repository. Placing an gregate instance in its corresponding repository, and later using that repository to rerieve the same instance, yields the expected whole object. If you alter a preexisting agregate instance that you retrieve from the repository its changes will be persisted. If you remove the instance from the repository, you will be unable to retrieve it from that point forwared. Set up access throught a well known global interface. Provide methods to add and remove objects... provide methods that select objects based on some criteria and return fully instantiated objects or collections of objects whose attribute values meet the criteria... provide repositories only for aggregates... there are two kinds of repository designs, a collection oriented design and a persistence oriented design. There are circumstances under which a collection-oriented design will work for you, and circumstances ehn it is best to use a presistence oriented design. I first discuss when to use and how to create a coolection oriented repository and follow that with a treatment of persistence oriented ones. Collection- Oriented Respositories We can consider a collection-oriented design a traditional paroach because it adheres to the basic ideas presented in the original ddd patter. These very cosely mimic a collection.