---
id: 1370
title: 'Domain-Driven Design. Modules &#038; Aggregates &#038; Respositories'
date: '2016-10-31T08:52:34+00:00'
author: Jose
layout: revision
guid: 'http://josecuellar.net/1337-revision-v1/'
permalink: '/?p=1370'
---

## Modules

 Los módulos son contenedores de elementos que nos permiten cierta organización entre los componentes definidos de nuestro dominio. Denominados técnicamente como packages o namespaces. El objetivo principal es desacoplar los elementos entre los elementos que se encuentran en diversos módulos. Siguiendo en todo momento el lenguaje obícuo. ### Module naming conventions for the model and submodules

 Normalmente y si la compañía dispone de un nombre de dominio en Internet, el módulo principal empezará con *com*, seguido del nombre de la organización. El siguiente segmento del nombre de módulo identifica el *Bounded Context* local donde se aloja el módulo o contenedor de elementos. No se recomienda utilizar los nombres comerciales de los productos de la organización en los nombres de módulos, ya que éstos pueden cambiar a lo largo del tiempo y en ocasiones no guarda relación directa con la responsabilidad del *Bounded Context* al que pertenece. Es preferible [identificar el nombre de cada contexto](/domain-driven-design-episodio-i-empezando/) según la organización que el equipo decida. El objetivo es reflejar el lenguaje obícuo de la organización. Los módulos deben identificar en qué componente del sistema se encuentra. En sistemas con arquitecturas por capas sería recomendable utilizar los nombres específicos según cada capa. Internamente en cada módulo de capa, debe desglosarse o dividirse según componentes internos en *submódulos*. ## Aggregates

 La *clusterización* o agrupación de *entidades* y *value objects* forman un Agregado. Encapsulando las relaciones que se establecen entre ellas actuando como un único conjunto con la finalidad de disminuir la complejidad de nuestro modelo de dominio. Cada agregado dispone de una Entidad Raíz (*Aggregate Root*) de la que *colgarán* el resto de *entidades* y *value Objects*. Siempre que se desee modificar cualquier componente interno del agregado debe realizarse a partir de métodos accesibles en dicha entidad raíz. Si las *entidades* o *value objects* relacionados necesitan persistir las modificaciones debe realizarse a través de la entidad raíz mediante servicios de aplicación y repositorios. <center> ![](/wp-content/uploads/FourSmallAggregates.png) </center>### Design Small Aggregates

 No se recomienda diseñar grandes agregados, dividiéndolos si fuese el caso en otros más pequeños según cada responsabilidad, permitiéndonos ser más escalables y trabajar con conjuntos de transacciones y lógicas más livianas y optimizadas. Disponiendo de los atributos mínimos necesarios en cada agregado. Favoreciendo así el uso de [](/domain-driven-design-episodio-v-services-domain-events/)Domain Events específicos, prestando atención especial a la consistencia eventual. Aunque no siempre es viable, debido a la existencia de posibles reglas de negocio que deban ser inmediatas y atómicas (en una misma transacción) mediante consistencia transaccional relacionadas a un único agregado. Deben discutirse con los expertos de dominio cada caso. Siguiendo siempre la regla de generar una única transacción por instancia de agregado. Nunca debemos cargar el agregado completamente (entidades y value objects relacionados), debemos utilizar [lazy loading](https://es.wikipedia.org/wiki/Lazy_loading) u otras técnicas que nos permitan cargar bajo demanda sus dependencias sin afectar al rendimiento. ### Reference other Aggregates by Identity

 Los agregados pueden relacionarse entre sí, únicamente mediante los identificadores de su entidad raíz: <center> ![](/wp-content/uploads/Aggregates.png) </center> <span style="font-size: 10px;">Fuente de ambas: [Modeling Aggregates with DDD and Entity Framework](https://vaughnvernon.co/?p=879).</span> Debemos evitar las propiedades asociativas conteniendo la instancia de la entidad root del otro agregado. Realizaremos dicha referencia mediante su identificador almacenado en un value object permitiéndonos separar e independizar las transacciones de ambos en transacciones, eventuales o no de forma aislada y separada. Ayudándonos a dividir de este modo los agregados para intentar diseñar siempre pequeños agregados. ### Model navigation

 Técnica también conocida como modelo de dominio desconectado. Enfoque recomendado para la optimización e inicialización de carga de componentes del sistema. Empleamos los repositorios o servicios de dominio para cargar los objetos dependientes de los agregados a través de los servicios de aplicación que orquestará y construirá el agregado completo necesario para el caso de uso que esté gestionando. Facilitando seguir la [ley de Demeter](https://es.wikipedia.org/wiki/Ley_de_Demeter). ### Scalability and distribution

 Since aggregates don´t use direct reference to other aggregates but reference by identity, their persistent state can be moved around to reach large scale. Almost infinite scalability is achieved by allowing for continous repartitioning of aggregate data storage, as explained by amazon.com. But what he describes is still an aggregate by any other name: a unit of composition that has transactional consistency. Some nowsql persistence. Since there are always multiple bounded contexts at play in a given core domain inititive, reference by identity allows distributed domain models to have associations from afar. When an event-driven approach is in use, message based domain events containing aggregate identities are send atound the enterprise. Message subscribers in foreign bounded contexts use the identity to carry out operations in their own domain models. Transactions across distributed systems are not atomic. Necesitamos despiezar las entidades o agregados para poder manipularlos de form distribuida sin perder la relacion mediante los identificaciones. Use eventual consistency outside the boundary: Any rule that spans aggregates will not be expected to be up to date at all times,. Throught event processing, batch processing, or other update mechanisms, other dependencies can be resolved within some specific time. Thus, if executing a command on one aggregate instance requires that additional business rules execute on or more other aggregate use eventual consistency. Ask the domain experts if they could tolerate some time delay between the modification of one instance and the others envolved. atomic change mentality not is good in disgributed systems. There is a practical way to support eventual consistency in a ddd model. An aggregate command method published a domain event that is in time delivered to one or more asyncrhronous subscribers. Each of these subscribers then retrieves a different yet corresponding aggregate instance and executes its behaviour based on it. Reasons to break the rules an experienced ddd practitiones may at time decide to persist changes to multiple aggregate instances in a signle transaction, but only with good reason. What might some reasons be? razon 1: user interface convenience. razon 2: lack of technical mechanisms in such cases project synamics may force us to modify two or more aggregate instance in one transaction. However obvious this might seem, such a decision should not be made too hastily. Razon 3: global transactions. razon 4 : query performance Rethinking the design, again create a root entity with unique identity using law of demeter and tell, don´t ask both law of demeter and tell, don´t ask are design principles that can be used when implementing aggregates, both of wich stress infromation hiding. Consider the high -level guiding principles to see how we can benefit: shourld know as little as possible about the server´s structure. The server´s attributes and properties- its shape- should remain completely unknown to the client. if the client needs a service that is rendered by the server´s inner parts, the client mus not be given access to the inner parts to request that behavior. Tell don´t ask: this guideline simply asserts that objects should be told what to do. The don´t ask part ot the guideline applies to the client as follows: a client object should not ask a server object for its contained parts, You will need to weigh the competing forcesbetween use of law of demeter and tell, don´t ask. Certainly the law of demeter approach is much more restrictive, disallowing all navigation into aggregate parts beyond the root. On the other hand, the use of tell, don´t ask allows for navigation beyond the root but does stipulate that modification of the aggregate state belongs to the aggregate , not the licent. You may thus find tell, don´t ask to be a more brodaly aplplicable approach to aggregate implementation. Opptimistic concurrency Next, we need to consider whre to place the optimistic concurrency version attribute. When we contemplate the definition of aggregate, it could seem safest to version only the root entity. The root´s version would be incremented every time a state-altering command is executed anywhereinside the aggregate boundary, no matter how deep. Using the running example, woul.... versión del objeto para determinar la modificcacione en los execute commands, para evitar bloquear el registro. Antes de persistir la entidad nos aseguramos de la verisón del objeto que hay ya persistido para evitar realizarla. FACTORIES Of all the patterns used in ddd, factory is probably one of the better known. Highly publicized in design patterns are abstract factory, factory method and builder. I won´t in any way attempt to overhadow the advice given there, or that provided by evans. The focus here is to provide examples of how you can use factories in the domain model. Shift the responsability for creating instances of complex objects and aggregates to a separate object, which may itself have no reponsability in the domain model but is still part of the domain design. Factory method for producing instance of another agregate type will have the primary responsability of providing it main agregate behavior, the factory medhod being just one of those. En vez de disponer de un constructor con un montón de parámetros dispondremos de un factory method que nos ayudará a generar la instancia del agregado dependiendo del lenguaje obicuo. The sample bounded context do in some cases require complex construction. evita que se generen instancias incorrectas controlando la complejidad de la instancia en ellas. factory on service. since much of whow i use services as factories is rrelated to nos ayuda a aprender como creamos instancias de agregados de otros tipos asegurándonos una correcta producción y iformación sensible. hemos aprendido omo los servicios de dominio pueden iddiseñarswe como factorieas incluyendo en otro dounded context y traduciendo bojetos locales. REPOSITORIES respository commonly referes to a storage location, usually considered a place of safety or preservation of the items stored in it. When you store something in a arepository and later return to retrive, you expect that it will be in the same state as ikt was in when you put it there. At some poing you may choose to remove the stored item from the repository. This basic set of principles applies to a ddd repository. Placing an gregate instance in its corresponding repository, and later using that repository to rerieve the same instance, yields the expected whole object. If you alter a preexisting agregate instance that you retrieve from the repository its changes will be persisted. If you remove the instance from the repository, you will be unable to retrieve it from that point forwared. Set up access throught a well known global interface. Provide methods to add and remove objects... provide methods that select objects based on some criteria and return fully instantiated objects or collections of objects whose attribute values meet the criteria... provide repositories only for aggregates... there are two kinds of repository designs, a collection oriented design and a persistence oriented design. There are circumstances under which a collection-oriented design will work for you, and circumstances ehn it is best to use a presistence oriented design. I first discuss when to use and how to create a coolection oriented repository and follow that with a treatment of persistence oriented ones. Collection- Oriented Respositories We can consider a collection-oriented design a traditional paroach because it adheres to the basic ideas presented in the original ddd patter. These very cosely mimic a collection. 