---
id: 1209
date: '2016-08-04T21:08:50+00:00'
author: Jose
layout: revision
guid: 'http://josecuellar.net/1190-revision-v1/'
permalink: '/?p=1209'
---

En este post introduciré estilos y patrones de arquitectura más interesantes y recomendables que puedes aplicar con DDD mencionados por Vaughn Vernon en [*"Implementing Domain-Driven Design”*](/domain-driven-design-episodio-i-empezando/). No es una lista detallada ni cerrada, ya que el enfoque táctico de *Domain-Driven Design* no requiere la utilización específica de ningún tipo de patrón o arquitectura: la verdadera importancia de cada *Bounded Context* reside en su *Core Domain* o modelo de dominio, independientemente de como se comunique con el resto de componentes de la aplicación, siempre y cuando se cumplan las [buenas prácticas y los principios de calidad apropiados](/principios-a-seguir-en-el-diseno-de-un-sistema/). Cualquier estilo o patrón que deseemos aplicar, deberá ser razonablemente justificado con tal de evitar la complejidad accidental. Intentando siempre disponer de la arquitectura y patrones mínimos necesarios para satisfacer los requisitos de cada *Bounded Context* a lo largo del tiempo.

## Layers - N-Tier Architecture

 Arquitectura más habitual. Separación de responsabilidades en capas particionando la complejidad según su responsabilidad. Siguiendo los principios [SoC](/principios-a-seguir-en-el-diseno-de-un-sistema/) y [SRP](/principios-a-seguir-en-el-diseno-de-un-sistema/). La capa superior depende de la inferior o inferiores: **Strict Layers Architecture:** Únicamente permite la dependencia con la capa directamente inferior. **Relaxed Layers Architecture:** Permite la dependencia con cualquiera de las capas inferiores. *Normalmente las tres capas mínimas habituales son: capa de presentación, negocio y acceso a datos.* Quizás te interese leer: [Estilos y patrones básicos en arquitectura de software](/estilos-patrones-basicos-arquitectura-software/)### Dependency Inversion Principle (Robert C. Martin)

 Los módulos de alto nivel no deben depender de módulos de bajo nivel. Ambos deben depender de abstracciones. Las abstracciones no deben depender de detalles, los detalles deben depender de las abstracciones. **En el siguiente diagrama podemos ver la arquitectura por capas habitual evolucionada/orientada a la nomenclatura y enfoque DDD mediante Relaxed Layers Architecture y aplicando Dependency Inversion Principle:** <center>![](/wp-content/uploads/layeredddd.png)</center> <span style="font-size: 10px;">Fuente: [DDD Architectures](http://www.papagrigoriou.com/blog/2015/architectures.html).</span> **Infractructure Layer**: Capa superior que implementa/provee todos los servicios de bajo nivel, que depende de las abstracciones o interfaces definidas/ubicadas en los componentes de alto nivel (*UI Layer, Application Layer, Domain Layer*). **User Interface Layer**: Capa de presentación gráfica al usuario, alojando los componentes necesarios para la visualización de datos, siendo recomendable utilizar un modelo específico mediante *ViewModels* desacoplado al modelo de dominio siguiendo así el patrón [MVVM](https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93viewmodel). No contiene lógica de negocio siendo el cliente directo de la capa de aplicación. **Application Layer**: Lógica de aplicación (no de negocio) mediante servicios (*Application Services*). Orientada a casos de uso de los usuarios, recibiendo los parámetros desde la capa de UI. Gestiona la interacción con recursos externos y el control de transacciones de persistencia, recuperación de datos y publicación/subscripción de eventos de aplicación (*Application Events*). Cliente directo de la capa de dominio. **Domain Layer**: Contiene la lógica de negocio mediante servicios (*Domain Services*) y modelado de dominio (*Domain Model*). Alojando las abstracciones o interfaces necesarias de acceso a datos (respositorios) y publicación/subscripción de eventos de dominio (*Domain Events*). ## Onion Architecture

 Siguiendo el estilo por capas enfocado a *DDD* y aunque *Vernon* no lo mencione en su libro: Creo importante destacar el estilo arquitectónico [Onion Architecture](http://jeffreypalermo.com/blog/the-onion-architecture-part-1/) que propone [Jeffrey Palermo](http://jeffreypalermo.com/). <center>![](/wp-content/uploads/onionarchitecture.png)</center> <span style="font-size: 10px;">Fuente: [The Onion Architecture](http://blog.mirkosertic.de/architecturedesign/onionarchitecture).</span> La principal ventaja o diferencia con la arquitectura por capas habitual se encuentra en extraer la base de datos del centro tratándola como un recurso externo. Siendo encargada la capa de infrastructura en implementar las interfaces de acceso a datos ubicadas en el dominio mediante [Repository Pattern](http://deviq.com/repository-pattern/). *Te dejo mi repositorio de Github con código de ejemplo: [DDD - Onion Architecture Example with C#](https://github.com/josecuellar/ddd-onion-architecture-net)*## Arquitectura Hexagonal (Ports and Adapters)

 <center>![](/wp-content/uploads/hexagonalarchitecture.PNG)</center> Comparte con *Onion Architecture* la premisa principal de favorecer el aislamiento y desacoplado, pero en este caso a través de *puertos y adaptadores* independientes que gestionan el *flujo de entrada y salida del sistema*. De igual modo, en el centro encontramos la capa de dominio o *core* y de aplicación, aunque las capas se comunican entre ellas usando interfaces (*ports*) e implementaciones (*adapters*). *Lectura recomendada: [Hexagonal architecture - Alistair Cockburn](http://alistair.cockburn.us/Hexagonal+architecture)*## Event-Driven Architecture (EDA)

 Arquitectura orientada al envío y recepción de eventos. Cualquier cambio de estado en las entidades o agregados de cualquier aplicación emitirán notificaciones. Otras aplicaciones, servicios o componentes internos o externos tratarán todas las eventualidades notificadas para aplicar las acciones requeridas según su contexto, emitiendo nuevos eventos si fuese necesario. Generando un tipo de comunicación que posibilita las transacciones eventuales y distribuidas. ### Event Sourcing

 Aplicar [Event Sourcing](http://martinfowler.com/eaaDev/EventSourcing.html) nos permitirá registrar notificaciones de los cambios de estado en cada entidad del modelo en un *Event Store* (habitualmente sistemas como [Akka](http://getakka.net/)), en el mismo orden que suceden y guardando un *snapshot* del estado de la entidad en el momento exacto de la notificación del evento (esto nos permite recuperar el estado de la entidad en cualquier momento en el tiempo o suceso). Los servicios subscritos recibirán la notificación por cada evento encargándose de efectuar las acciones de modificación y sincronización de datos necesarias en cada caso ([Eventual consistency](https://en.wikipedia.org/wiki/Eventual_consistency)). Favoreciendo además el desacoplamiento de responsabilidades y facilitando la integración entre *Bounded Contexts*. ## Command-Query Responsability Segregation (CQRS)

 Separación del modelo en *Command* (persistencia) y *Query* (recuperación) creando modelos de persistencia (*Command Model*) y consulta (*Query Model*) independientes. Si el método modifica el estado del objeto se trata de un *command*, y el método no debe retornar ningún valor. En cambio si retorna ulgún valor, será *query* y no debe, directa o indirectamente, causar la modificación del estado del objeto. En la mayoría de los casos no necesitamos toda la información de una determinada entidad para mostrarla al usuario: separar los modelos nos ayudará a optimizar las consultas a la base de datos recuperando únicamente los necesarios. Además, nos permite disponer de una base datos independiente con datos desnormalizados (habitualmente bases de datos [NoSql](https://es.wikipedia.org/wiki/NoSQL)), evitando así realizar JOINS entre tablas, mejorando en gran medida el rendimiento. Necesitamos asegurarnos un sistema de actualización de la base de datos y modelo *query* dadas las modificaciones por los servicios *command* a la base de datos principal. Dicha actualización puede realizarse de forma *síncrona* o *asíncrona* dependiendo de la necesidad y técnica empleada en cada caso. La actualización de los cambios pueden realizarse mediante la creación de procesos de sincronización o configurando [triggers](https://es.wikipedia.org/wiki/Trigger_(base_de_datos)) para tal fin: <center>![](/wp-content/uploads/cqrs2.PNG)</center> Aunque no sería estrictamente necesario abarcar el paradigma *Event Sourcing* para aplicar *CQRS*. Mediante un *broker message* como [RabbitMQ](https://www.rabbitmq.com/) sería suficiente: <center>![](/wp-content/uploads/cqrs1.PNG)</center> Debemos decidir en cada caso si realmente es necesario el uso de *CQRS*, ya que puede aumentar el riesgo de ocasionar complejidad en la arquitectura. *Lectura recomendadas: [CQRS, Fowler](http://martinfowler.com/bliki/CQRS.html) [Clarified CQRS, Dahan](http://udidahan.com/2009/12/09/clarified-cqrs/)* One of the longest running ways to think about an enterprise application is as a system that reacts to events from the outside world. This is a way of thinking that became established in the structured design community in the second half of the 80's. You hear of it now under the banner of "Event-Driven Architecture". 