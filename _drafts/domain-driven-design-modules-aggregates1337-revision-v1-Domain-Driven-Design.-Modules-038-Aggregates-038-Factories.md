---
id: 1407
title: 'Domain-Driven Design. Modules &#038; Aggregates &#038; Factories'
date: '2016-10-31T13:24:02+00:00'
author: Jose
layout: revision
guid: 'http://josecuellar.net/1337-revision-v1/'
permalink: '/?p=1407'
---

## Modules

 Los módulos son contenedores de elementos que nos permiten la organización de nuestro dominio. Denominados técnicamente como *packages* o *namespaces*. El objetivo principal es desacoplar y organizar los elementos dependiendo del contexto al que pertenecen. Siguiendo en todo momento el *lenguaje obicuo*. ### Module naming conventions for the model and submodules

 Normalmente y si la compañía dispone de un nombre de dominio en Internet, el módulo principal empezará con *com*, seguido del nombre de la organización. El siguiente segmento del nombre de módulo identifica el *Bounded Context* local donde se aloja el módulo o contenedor de elementos. No se recomienda utilizar los nombres comerciales de los productos de la organización en los nombres de módulos o submódulos, ya que éstos pueden cambiar a lo largo del tiempo y en ocasiones no guarda relación directa con la responsabilidad del *Bounded Context* al que pertenece. Es preferible [identificar el nombre de cada *Bounded Context*](/domain-driven-design-episodio-i-empezando/) según la organización que el equipo decida. El objetivo es reflejar el lenguaje obicuo de la organización. Los siguientes segmentos deben identificar en qué componente del sistema se encuentra. En sistemas con arquitecturas por capas sería recomendable utilizar los nombres específicos según cada capa. ## Aggregates

 La *clusterización* o agrupación de *entities* y *value objects* forman un Agregado. Encapsulando las relaciones que se establecen entre ellas actuando como un único conjunto con la finalidad de disminuir la complejidad de nuestro modelo de dominio y agrupar responsabilidades. Cada agregado dispone de una entidad raíz (*aggregate root*) de la que *colgarán* el resto de *entities* y *value objects*. Siempre que se desee modificar cualquier componente interno del agregado debe realizarse a partir de **métodos accesibles en dicha entidad raíz**. Si las *entities* o *value objects* internos necesitan persistirse debe realizarse a través de la entidad raíz mediante servicios de aplicación y repositorios que reconstruirán y persistirán el agregado. <center> ![](/wp-content/uploads/FourSmallAggregates.png) </center>### Design Small Aggregates

 No se recomienda diseñar grandes agregados. Dividiéndolos en la medida de lo posible en otros más pequeños. Permitiéndonos así ser más escalables trabajando con transacciones y lógicas más livianas y aisladas favoreciendo el enfoque de [Domain Events](/domain-driven-design-episodio-v-services-domain-events/). Por motivos de rendimiento es aconsejable no cargar o reconstruir el agregado completamente (*entities* y *value objects* relacionados) empleando [lazy loading](https://es.wikipedia.org/wiki/Lazy_loading) u otras técnicas que nos permitan cargar bajo demanda sus *dependencias*. Manteniendo pequeños agregados evitaremos reconstruir y persistir grandes agregados que puedan penalizar al *rendimiento*. No siempre es posible separar agregados, debido a **posibles reglas de negocio que deban ser inmediatas y atómicas** (en una misma transacción) mediante *consistencia transaccional* relacionadas a un único agregado. Deben discutirse con los *expertos de dominio* cada caso. Siguiendo siempre la regla de **generar una única transacción por instancia de agregado**. ### Reference other Aggregates by Identity

 Los agregados pueden relacionarse entre sí únicamente mediante los identificadores de su *entidad raíz*: <center> ![](/wp-content/uploads/Aggregates.png) </center> <span style="font-size: 10px;">Fuente de ambas: [Modeling Aggregates with DDD and Entity Framework](https://vaughnvernon.co/?p=879).</span> Debemos evitar las propiedades asociativas conteniendo la instancia de la entidad *root* del otro agregado. Realizaremos dicha referencia mediante su identificador almacenado en un *value object*. ### Model navigation

 Manteniendo pequeños agregados y relacionándolos mediante identificadores nos ayuda a emplear *Model navigation*: técnica también conocida como modelo de dominio desconectado. Empleamos los repositorios o servicios de dominio para cargar los objetos dependientes de los agregados a través de los servicios de aplicación gracias a los identificadores que lo componen. ### Law of Demeter and tell, don´t ask

 Ambas son principios de diseño que pueden ser seguidos para crear los agregados. Los clientes que consumen el agregado no deben conocer los detalles de implementación, ni navegar entre referencias internas. Los atributos, propiedades, elementos y comportamientos internos del agregado no deben ser accesibles por el cliente. La [ley de Demeter](https://es.wikipedia.org/wiki/Ley_de_Demeter) no permite la navegación directa entre referencias internas de un agregado. Por otro lado [Tell, don´t Ask](http://martinfowler.com/bliki/TellDontAsk.html) permite la navegación a través del agregado, pero debemos encapsular/ocultar los detalles de implementación. Puedes echar un vistazo a [algunas leyes en el desarrollo de software](/algunas-leyes-en-el-desarrollo-de-software/) y a los [principios básicos en el desarrollo de software](/principios-a-seguir-en-el-diseno-de-un-sistema/). ### Example

 Podemos resumir de forma muy gráfica uno de los ejemplos que explica *Vaughn Vernon* en *Implementing Domain-Driven Design*. Dado este primer agregado lo primero que debemos cuestionarnos es el tamaño, con intención siempre de separarlo en varios, aplicando y desarrollándolo según recomendaciones: <center> ![](/wp-content/uploads/LargeAggregate.png) </center> Su representación en código: <center> ![](/wp-content/uploads/LargeAggregateCode.png) </center> A pesar que pueda ser atractivo crear grandes agregados. Debemos separarlo guardando la relación con sus identificadores. Creando así nuevos agregados relacionados: <center> ![](/wp-content/uploads/SeparateAggregates.png) </center> Tomando como ejemplo uno de los nuevos agregados creados y haciendo *zoom*, podemos ver sus elementos internos relacionados: <center> ![](/wp-content/uploads/SeparateAggregates2.png) </center> De igual modo, cualquiera de las relaciones de los nuevos agregados que creemos realizando la separación será mediante sus identificadores almacenados en *value objects*: <center> ![](/wp-content/uploads/SeparateAggregates3.png) </center> Hasta aquí lo que creo más relevante en Modules y diseño de Aggregates. Espero que te haya servido de ayuda. Te dejo algunos enlaces interesantes para ampliar esta información: 